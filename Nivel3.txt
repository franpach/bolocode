import robocode.*;
import static robocode.util.Utils.normalRelativeAngleDegrees;
import java.awt.*;

// API help : http://robocode.sourceforge.net/docs/robocode/robocode/Robot.html

/**
 * Nivel 3 - a robot by Francisco Javier Pacheco Herranz y Javier Romero PÃ©rez
 * 
 * The robot locks an enemy when scanned and follows it while shooting
 */
public class NOMBRECLASE extends AdvancedRobot
{
	static double enemyAbsoluteBearing;
	private int timeSinceLastScan = 5;
	/**
	 * run: Prueba's default behavior
	 */
	public void run() {

		setColors(COLORBODY,COLORGUN,COLORRADAR); // body,gun,radar

		// Battlefield size
		setAdjustGunForRobotTurn(true); // if the robot is turned, don't turn the gun

		setAdjustRadarForGunTurn(true); // if the gun is turned, don't turn the radar
		double battleFieldWidth = getBattleFieldWidth();
		double battleFieldHeight = getBattleFieldHeight();
		
		// Ahead distance factor 
		// Robot will move forward this distance, calculated depending on the battlefield size
		double aheadDistance = 0;
		
		// Direction (in degrees) the robot is facing
		double heading = 0;
		
		//(x,y) robot position
		double x = 0;
		double y = 0;
		
		// Remaining distance to wall
		double remainingHeight = 0;
		double remainingWidth = 0; 	
		double closestWall = 0;
		
		// Robot size
		double robotHeight = getHeight();
		double robotWidth = getWidth();
		
		// Battlefield loops counter
		int loopsCounter = 0;
		
		// Robot main loop
		while(true) {
			doScanner();
			//execute();//Executes pending actions
			x = getX(); // We supose that the (x,y) position is the central pixel of the robot
			y = getY();
			heading = getHeading();
			
			if(heading >= 0 && heading < 90) {	// Facing northeast 
				remainingHeight = battleFieldHeight - y;
				remainingWidth = battleFieldWidth - x;
				if (remainingHeight < 50 || remainingWidth < 50) {
					closestWall = Math.min(remainingHeight, remainingWidth);
					if(closestWall == remainingHeight) 
						turnRight(60);
					else 
						turnLeft(60);
					++loopsCounter;
					if (loopsCounter > 4) {
						loopsCounter = 0;
						turnLeft(180);
					}
				}
				else
					ahead(30);	
			}
			else if(heading >= 90 && heading < 180) { // Facing southeast
				remainingHeight = y;
				remainingWidth = battleFieldWidth - x;
				if (remainingHeight < 50 || remainingWidth < 50) {
					closestWall = Math.min(remainingHeight, remainingWidth);
					if(closestWall == remainingHeight) 
						turnLeft(60);
					else 
						turnRight(60);
					++loopsCounter;
					if (loopsCounter > 4) {
						loopsCounter = 0;
						turnLeft(180);
					}
				}
				else
					ahead(30);
			}
			
			else if (heading >= 180 && heading < 270) { // Facing southwest
				remainingHeight = y;
				remainingWidth = x;
				if (remainingHeight < 50 || remainingWidth < 50) {
					closestWall = Math.min(remainingHeight, remainingWidth);
					if(closestWall == remainingHeight) 
						turnRight(60);
					else
						turnLeft(60);
					++loopsCounter;
					if (loopsCounter > 4) {
						loopsCounter = 0;
						turnLeft(180);
					}
				}
				else
					ahead(30);
			}
			else { // Facing northwest
				remainingHeight = battleFieldHeight - y;
				remainingWidth = x;
				if (remainingHeight < 50 || remainingWidth < 50) {
					closestWall = Math.min(remainingHeight, remainingWidth);
					if(closestWall == remainingHeight) 
						turnLeft(60);
					else 
						turnRight(60);
					++loopsCounter;
					if (loopsCounter > 4) {
						loopsCounter = 0;
						turnLeft(180);
					}
				}
				else
					ahead(30);
			}
		}
	}
		
	/**
	 * onScannedRobot: What to do when you see another robot
	 */
	public void onScannedRobot(ScannedRobotEvent e) {
		
		enemyAbsoluteBearing = getHeadingRadians() + e.getBearingRadians(); 
		timeSinceLastScan = 0; 
		if(e.getDistance() <= 300)
		{
			
				if(getEnergy() > 50)
				{
				
				fire(3);
				}
				else
				{
					fire(1);
				}
			
		}
	}

	/**
	 * onHitByBullet: What to do when you're hit by a bullet
	 */
	public void onHitByBullet(HitByBulletEvent e) {
		double bearing = e.getBearing();
		turnRight(bearing*-1);
		ahead(10);
	}
	
	/*
	 * getQuadrant: returns the quadrant in which the robot sets
	 */
	private int getQuadrant(double x, double y, double battleFieldHeight, double battleFieldWidth) {
			int quadrant = 0;
			if(y > battleFieldHeight/2) { 
				if (x < battleFieldWidth/2) 
					quadrant = 0;
				else
					quadrant = 1;
			}
			else {
				if (x < battleFieldWidth/2) 
					quadrant = 3;
				else
					quadrant = 2;
			}	
			return quadrant;
	}
	
	public void doScanner() {

		timeSinceLastScan++; 
		double radarOffset = Double.POSITIVE_INFINITY; 
		
		if(timeSinceLastScan < 3) {
			radarOffset = robocode.util.Utils.normalRelativeAngle(getRadarHeadingRadians()
			- enemyAbsoluteBearing);
	
			radarOffset += sign(radarOffset) * 0.02;
	
			}
	
			setTurnRadarLeftRadians(radarOffset); 
	
			setTurnGunLeftRadians(getGunHeadingRadians() - getRadarHeadingRadians());
			setTurnLeft(radarOffset);
			ahead(10);
		}

	private int sign(double v) {
		return v > 0 ? 1 : -1;
	}

	/**
	 * onHitWall: What to do when you hit a wall
	 */
	public void onHitWall(HitWallEvent e) {
		// Replace the next line with any behavior you would like
		turnLeft(180);
	}	
}
